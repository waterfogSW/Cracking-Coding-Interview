# BFS / DFS
트리를 탐색하는 알고리즘에는 크게 너비 우선 탐색(BFS)방식과 깊이 우선 탐색(DFS)방식이 있습니다. 두가지 방식 모두 모든 노드를 방문하지만 탐색을 수행하는 방식에 있어 약간의 차이가 있습니다.

## BFS
BFS(Breadth First Search)는 너비 우선 탐색방식으로 루트 노드에서부터 시작하여 각 노드를 레벨에따라 순차적으로 방문하며, 루트 노드로 부터 멀리떨어진 노드를 가장 나중에 방문하는 순회방법입니다.

주로 **큐(Queue)** 자료구조를 통해 구현되며 DFS방식에 비해 더 많은 메모리를 사용합니다.

두 노드간의 최단 경로 찾기, 그래프가 분리 가능한지 테스트, 그래프에 연결된 모든 구성요소 찾기 등에 사용됩니다.

## DFS
DFS(Depth First Search)는 깊이 우선 탐색방식으로 루트 노드에서부터 시작하여 깊이 내려간뒤(루트노드에서 먼쪽)더이상 내려갈 곳이 없을경우 옆으로 이동하여 탐색을 반복합니다.

주로 **스택(Stack)** 자료구조나 **재귀함수**를 통해 구현되며 BFS방식에 비해 더 적은 메모리를 사용합니다.

토폴로지 정렬, 그래프 백트래킹이 필요한 문제 해결, 그래프의 사이클 탐지, 두 노드간 경로 찾기 등에 사용됩니다.

## Compare

| -   | BFS | DFS |
| --- | --- | --- |
| DEF  | 너비우선탐색    | 깊이우선탐색    |
| SRC | 경로의 특징을 저장해 둬야하는 문제의 경우 DFS를 사용합니다. | 최단거리를 구해야 하는 문제의 경우 BFS를 사용합니다 |
| SPD | DFS에 비해 느립니다 | BFS에 비해 빠릅니다 |
| O(n) | 간선의 개수를 E, 노드의 개수를 V라 하면 시간복잡도는 O(V+E)입니다 | O(V+E)

## Example

1. 타겟 넘버  
n개의 음이 아닌 정수가 있습니다. 이 수를 적절히 더하거나 빼서 타겟 넘버를 만들려고 합니다. 예를 들어 [1, 1, 1, 1, 1]로 숫자 3을 만들려면 다음 다섯 방법을 쓸 수 있습니다.
> -1+1+1+1+1 = 3  
> +1-1+1+1+1 = 3  
> +1+1-1+1+1 = 3  
> +1+1+1-1+1 = 3  
> +1+1+1+1-1 = 3

사용할 수 있는 숫자가 담긴 배열 numbers, 타겟 넘버 target이 매개변수로 주어질 때 숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 return 하도록 solution 함수를 작성해주세요.

DFS를 통한 솔루션
```c++
int DFS(vector<int> numbers, int target) {
    if(numbers.size() == 0) {
        if(target == 0) return 1;
        else return 0;
    }
    int tmp = numbers.back();
    numbers.pop_back();
    return DFS(numbers, target + tmp) + DFS(numbers, target - tmp);
}
```